<script>
  import { signal, animatedSignal, effect, computed } from 'canvasengine'
  import { Bar } from '../src/presets/Bar'

  enum Direction {
    Down = "down",
    Left = "left",
    Right = "right",
    Up = "up",
  }

  enum Animation {
    Stand = "stand",
    Walk = "walk",
    Attack = "attack",
    Skill = "skill",
  }

  const x = animatedSignal(700);
  const y = animatedSignal(400);
  const direction = signal(Direction.Down);
  const speed = 5;

  const controls = signal({
    down: {
      repeat: true,
      bind: ["down", 'bottom_right', 'bottom_left'],
      trigger() {
        y.update((y) => y + speed);
        direction.set(Direction.Down);
      },
    },
    up: {
      repeat: true,
      bind: ['up', 'top_left', 'top_right'],
      trigger() {
        y.update((y) => y - speed);
        direction.set(Direction.Up);
      },
    },
    left: {
      repeat: true,
      bind: "left",
      trigger() {
        x.update((x) => x - speed);
        direction.set(Direction.Left);
      },
    },
    right: {
      repeat: true,
      bind: "right",
      trigger() {
        x.update((x) => x + speed);
        direction.set(Direction.Right);
      },
    },
  });

  const LPCSpritesheetPreset = () => {
    const frameY = (direction: Direction) => {
      return {
        [Direction.Down]: 2,
        [Direction.Left]: 1,
        [Direction.Right]: 3,
        [Direction.Up]: 0,
      }[direction];
    };

    const stand = (direction: Direction) => [
      { time: 0, frameX: 0, frameY: frameY(direction) },
    ];
    const anim = (
      direction: Direction,
      framesWidth: number,
      speed: number = 5
    ) => {
      const array: any = [];
      for (let i = 0; i < framesWidth; i++) {
        array.push({ time: i * speed, frameX: i, frameY: frameY(direction) });
      }
      return array;
    };

    const ratio = 1.5;

    return {
      id: "hero",
      image: "./hero_2.png",
      width: 1248,
      height: 2016,
      opacity: 1,
      rectWidth: 64 * ratio,
      rectHeight: 64 * ratio,
      spriteRealSize: {
        width: 48 * ratio,
        height: 52 * ratio,
      },
      framesWidth: 6,
      framesHeight: 4,
      textures: {
        [Animation.Stand]: {
          offset: {
            x: 0,
            y: 512 * ratio,
          },
          animations: ({ direction }) => [stand(direction)],
        },
        [Animation.Walk]: {
          offset: {
            x: 0,
            y: 512 * ratio,
          },
          framesWidth: 9,
          framesHeight: 4,
          animations: ({ direction }) => [anim(direction, 9)],
        },
        [Animation.Attack]: {
          offset: {
            x: 0,
            y: 768 * ratio,
          },
          framesWidth: 6,
          framesHeight: 4,
          animations: (direction: Direction) => [anim(direction, 6, 3)],
        },
        [Animation.Skill]: {
          framesWidth: 7,
          framesHeight: 4,
          animations: (direction: Direction) => [anim(direction, 7, 3)],
        },
      },
    };
  };

  const sheet = {
    definition: LPCSpritesheetPreset(),
        params: {
            direction,
        },
    }

    const health =  animatedSignal(100, {
      duration: 300,
    });

    const healthMax = signal(100);
    
    const textHealth = computed(() => Math.round(health()) + "%");

    const mapColor = {
        20: "#fb6f92",   // Color for 0% or less
        40: "#ffb3c6",  // Color for 25% or less
        70: "#588157",  // Color for 50% or less
        90: "#344e41"   // Color for 75% or more
    };
    
    const getForegroundColor = (value, max, colorMap = mapColor, defaultColor = "#FFFFFF") => {
        const percentage = (value / max) * 100;
        const thresholds = Object.keys(colorMap).map(Number).sort((a, b) => a - b);
        
        for (const threshold of thresholds) {
            if (percentage <= threshold) {
                return colorMap[threshold];
            }
        }
        
        return colorMap[thresholds[thresholds.length - 1]] || defaultColor;
    };

    const foregroundColor = signal("#344e41");

    health.observable.subscribe((value) => {
        foregroundColor.set(getForegroundColor(value, healthMax()));
    });

</script>

<Container x y controls 
  zIndex={y} 
  viewportFollow="true"
  flexDirection="column" 
  alignItems="center"
>
  <NineSliceSprite
    image="https://s3-us-west-2.amazonaws.com/s.cdpn.io/693612/speech_bubble.png"
    width="400"
    height="300"
  />
  <Text text={textHealth} style={{ fontSize: 20, align: 'center' }} />
  <Bar 
    width="100" 
    height="12" 
    value={health} 
    maxValue={healthMax} 
    backgroundColor="#000000"
    foregroundColor={foregroundColor}
    margin={ [10, 0, 0, 0] }
    borderRadius="5"
    innerMargin="2"
  /> 
  <Sprite sheet @click={() => health.update((health) => health - 10)} />
</Container>